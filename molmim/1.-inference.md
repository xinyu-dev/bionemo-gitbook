
# Inference

## Prerequisites

1. Set up the BioNeMo Framework container 
2. You will also need pretrained model checkpoint `.nemo` file. You can either use the pretrained models we provided or train your own.  



## Steps
There are 2 ways to generate embeddings using MolMIM: 

1. through interactive inference (wihtout explictly launching triton server)
2. through triton server. 

### Method 1. Interactive Inference

1. Download [this notebook](../.gitbook/assets/notebooks/MolMIM/inference_interactive.ipynb). Save it under `examples/molecule/molmim/nbs/` in the Jupyter Lab environment.
2. Run the notebook. 

### Method 2. Triton Server
1. Open a terminal in the Jupyter lab. 
2. Launch the triton server with the following command: 

    ```bash
        python -m bionemo.triton.inference_wrapper \
        --config-path /workspace/bionemo/examples/molecule/molmim/conf \
        --config-name infer.yaml
    ```

    - The triton server will be launched at locally. Give it a few minutes.  
    - `--config-path` is the path to the folder containing the `YAML` config file.
    - `--config-name` is the name of the `YAML` config file inside the `--config-path` folder.

3. Download [this notebook](../.gitbook/assets/notebooks/MolMIM/inference.ipynb). Save it under `examples/molecule/molmim/nbs/` in the Jupyter Lab environment.
4. Run the notebook.

## Notes
### Consistency between embeddings
The embeddings generated from a non-canonical SMILES and its canoncial form are different. In addition, we have observed that there are rounding errors in the embeddings generated by MolMIM in different batches. 

For example, consider the following example: 
```python
def canonicalize_smiles(smiles: str) -> str:
    """Canonicalize input SMILES"""
    mol = Chem.MolFromSmiles(smiles)
    canon_smiles = Chem.MolToSmiles(mol, canonical=True)
    return canon_smiles
# a test SMILES
s = 'c1cc2ccccc2cc1'
# canonicalize the SMILES
cs = canonicalize_smiles(s)
# different test cases
smis1 = [s] # original
smis2 = [cs] # original canoicalized
smis3 = [s, s] # orignial*2
```

We will embed `smis1`, `smis2`, and `smis3` and compare the embeddings. 

```python
test1 = inferer.seq_to_embeddings(smis1)[0, :].cpu()
test2 = inferer.seq_to_embeddings(smis2)[0, :].cpu()
test3 = inferer.seq_to_embeddings(smis3)[0, :].cpu()
```

**Compare original [s] vs canonicalized  [cs] produce very different embeddings**: 
```python
# absolute difference
np.allclose(test1, test2, atol=1e-01, rtol=0)
# returns False

# cosine similarity
cos_sim = cosine_similarity(test1.reshape(-1, 1), test2.reshape(-1, 1))
np.mean(np.diag(cos_sim))
# returns 0.5625
```

**Comparing [s] vs [s, s] generates similar embeddings, up to a certain threshold 1e-3**
```python
# absolute difference
np.allclose(test1, test3, atol=1e-03, rtol=0)
# returns True. If you change the threshold to 1e-04, it will return False.

# cosine similarity
cos_sim = cosine_similarity(test1.reshape(-1, 1), test3.reshape(-1, 1))
np.mean(np.diag(cos_sim))
# returns 1
```

**The solution: to generate the exact same embedding of a given molecule, use a batch size of 1 when running the inference. For example:**
```python
N = 10
# running inference 10 time
for n in range(N): 
	# but each time, we only embed 1 smiles
    result = inferer.seq_to_embeddings(smis1)[0, :].cpu()
    # this generates exactly the same array per round
    assert np.array_equal(test1, result)
    # cosine = 1 for all rounds
    assert np.mean(np.diag(cosine_similarity(test1.reshape(-1, 1), result.reshape(-1, 1)))) == 1
```

To try it out,  refer to [this notebook](../.gitbook/assets/notebooks/MolMIM/molmim_embedding_consistency.ipynb)

